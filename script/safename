#!/usr/bin/perl

use 5.006;
use strict;
use warnings;

use Encode qw(decode encode);
use Encode::Safename;
use File::Basename;
use File::Find;
use Getopt::Long;

# process options from the command line
my $encode = 0;
my $decode = 0;
my $recursive =0;
my $testmode = 0;
my $verbose = 0;

GetOptions(
    'encode'    => \$encode,
    'decode'    => \$decode,
    'recursive' => \$recursive,
    'test'      => \$testmode,
    'verbose'   => \$verbose,
);

unless ($encode || $decode) {
    # missing command
    die "missing command\n";
}

sub _rename {
    # process arguments
    my $old = shift;
    $old = decode('utf-8', $old);

    # skip non-existent files
    if (! -e $old) {
        return;
    }

    # split into directory and filename
    my $filename = basename($old);
    my $directory = dirname($old);

    my $new;

    if ($encode) {
        # try to encode the filename
        $new = encode('safename', $filename, 1);
        die "can't encode '$filename'" if $filename;
        $new = "$directory/$new";
    }
    elsif ($decode) {
        # try to decode the filename
        $new = decode('safename', $filename, 1);
        die "can't decode '$filename'" if $filename;
        $new = "$directory/$new";
    }

    # encode paths
    $old = encode('utf-8', $old);
    $new = encode('utf-8', $new);

    if ($old ne $new) {
        # old and new filename are not the same
        if (! $testmode) {
            # not in test mode
            rename($old, $new);
        }

        if ($verbose) {
            # verbose
            print "'$old' -> '$new'\n";
        }
    }
}

foreach my $path (@ARGV) {
    # process paths from the command line
    if ($recursive && -d $path) {
        # process paths recursively
        finddepth({
                no_chdir => 1,
                wanted   => sub {
                    _rename($File::Find::name);
                },
            },
            $path,
        );
    }
    else {
        # process single path
        _rename($path);
    }
}

__END__

=head1 NAME

safename - rename files to safe filenames

=head1 VERSION

version 0.01

=head1 SYNOPSIS

    safename (--decode | --encode) [--recursive] [--test]
             [--verbose] [files or directories]

=head1 OPTIONS

    --decode, -d       decode from safe filenames
    --encode, -e       encode to safe filenames
    --recursive, -r    rename files recursively
    --test, -t         don't actually rename files
    --verbose, -v      print all renamed files

=head1 EXAMPLES

Rename a file to a safe filename:

    $ safename -e Foo.txt

Rename a file from a safe filename:

    $ safename -d {f}oo.txt

=head1 LICENSE AND COPYRIGHT

Copyright 2013 Bert Vanderbauwhede.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

See http://www.gnu.org/licenses/ for more information.

=cut
