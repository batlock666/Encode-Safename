#!/usr/bin/perl

use 5.006;
use strict;
use warnings;

use Encode qw(decode encode);
use Encode::Safename;
use File::Basename;
use File::Find;
use Getopt::Std;

# constants
use constant CMD_ENCODE => 'encode';
use constant CMD_DECODE => 'decode';

# process options from the command line
my %options;
getopts('edrtv', \%options);

# process the command
my $command;
if ($options{'e'}) {
    # encode
    $command = CMD_ENCODE;
}
elsif ($options{'d'}) {
    # decode
    $command = CMD_DECODE;
}
else {
    # missing command
    die "missing command\n";
}

# process flags
my $recursive = $options{'r'};
my $testmode = $options{'t'};
my $verbose = $options{'v'};

sub _rename {
    # process arguments
    my $old = shift;
    $old = decode('utf-8', $old);

    # split into directory and filename
    my $filename = basename($old);
    my $directory = dirname($old);

    my $new;

    if ($command eq CMD_ENCODE) {
        # try to encode the filename
        $new = encode('safename', $filename, 1);
        die "can't encode '$filename'" if $filename;
        $new = "$directory/$new";
    }
    elsif ($command eq CMD_DECODE) {
        # try to decode the filename
        $new = decode('safename', $filename, 1);
        die "can't decode '$filename'" if $filename;
        $new = "$directory/$new";
    }

    # encode paths
    $old = encode('utf-8', $old);
    $new = encode('utf-8', $new);

    if ($old ne $new) {
        # old and new filename are not the same
        if (! $testmode) {
            # not in test mode
            rename($old, $new);
        }

        if ($verbose) {
            # verbose
            print "'$old' -> '$new'\n";
        }
    }
}

foreach my $path (@ARGV) {
    # process paths from the command line
    if ($recursive && -d $path) {
        # process paths recursively
        finddepth({
                no_chdir => 1,
                wanted   => sub {
                    _rename($File::Find::name);
                },
            },
            $path,
        );
    }
    else {
        # process single path
        _rename($path);
    }
}

__END__

=head1 NAME

safename - rename files to safe filenames

=head1 VERSION

version 0.01

=head1 SYNOPSIS

    safename (-d | -e) [-r] [-t] [-v] [files or directories]

=head1 OPTIONS

    -d    decode from safe filenames
    -e    encode to safe filenames
    -r    rename files recursively
    -t    don't actually rename files
    -v    print all renamed files

=head1 EXAMPLES

Rename a file to a safe filename:

    $ safename -e Foo.txt

Rename a file from a safe filename:

    $ safename -d {f}oo.txt

=head1 LICENSE AND COPYRIGHT

Copyright 2013 Bert Vanderbauwhede.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

See http://www.gnu.org/licenses/ for more information.

=cut
